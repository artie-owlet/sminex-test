# Implementation notes

## Используемый стек и причины выбора

* Express для обработки запросов - использовал раньше на практике.
* Postgres для хранения данных - большой опыт использования (по сравнению с Mysql/MariaDB). NoSQL не рассматривал, так как нет практического опыта.
* pg для работы с БД - выбрал в силу привычки. Рассматривал knex, но на чистом SQL мне проще писать сложные запросы. Очевидные минусы (по сравнению с knex) - требует больше внимательности, сами запросы сложно покрыть тестами.
* mocha + chai + nyc - использовал раньше на практике.
* swagger-ui-express - следовал общепринятой практике (но самому не нравится идея встраивания документации прямо в сервис).

## Структура приложения

В папке service классы, отвечающие за работу с внешними ресурсами (в данном случае - с БД).

В папке model - бизнес-логика сервиса. Разделение на классы / глобальные методы по семантике:

* Auth - создание и проверка сессии (методы login и auth соответственно).
* Client - методы API для обычного пользователя.
* Admin - методы API для администрирования (управление пользователями, пополнение справочника).
* onError - перехват и обработка ошибок, агностичный к источнику и причине возникновения.

## Аутентификация

Механизм с парой токенов access + refresh - общая практика (в случаях, когда клиент - приложение для так сказать человека, а не другой сервис).

## Управление пользователями

Вообще для администрирования (а также авторизации) следовало бы делать отдельные сервисы - проще, безопаснее и соблюдается принцип разделения ответственности. Сделал метод setUser больше для удобства, в реальном приложении для этого нужен полноценный API.

## Работа с БД

Используется пул соединений. Методы классов Admin и Client используют отдельные пулы и работают с БД через отдельные роли с разными правами доступа - старая практика управления доступом к БД.

## Структура справочника в БД

Выбрал реализацию через единую таблицу. Также рассматривал вариант создать несколько таблиц (по таблице на каждый уровень классификаторов) и связать таблицы-уровни через FOREIGN KEY, но это сложнее и скорее всего не дает ощутимых преимуществ. Связность данных (если вдруг нужно будет удалять классификаторы) реализовал через триггер.

## Конфигурация

Конфиг генерируется из переменных окружения - наиболее простая практика, если сервис работает в контейнере (по сравнению с, например, .env файлом или генерацией конфига сначала в json-файл).

## Документация

API описал отдельно в стороннем редакторе (на swagger.io) и вставил в сервис через swagger-ui-express. Такой подход мне не нравится, просто сделал "как все". Подход, который мне нравится больше (но нужно время, чтобы разобраться):

* Документировать методы прямо в коде.
* Сгенерировать спецификацию с помощью swagger-jsdoc.
* Сгенерировать страницу с документацией с помощью swagger-ui и выложить ее, например, на github pages.
* Автоматизировать пункты 2-3 в виде actions.
